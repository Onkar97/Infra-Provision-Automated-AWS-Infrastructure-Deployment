name: 'Packer Build AMI'

on:
  pull_request:
    branches:
      - main
    types:
      - closed

jobs:
  build-and-deploy:
    # If the pull request is merged then perform
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    # Define the PostgreSQL service container
    services:
      postgres:
        image: postgres:17
        # Set up the database using the service's environment variables
        env:
          POSTGRES_USER: ${{ secrets.DBUSER }}
          POSTGRES_PASSWORD: ${{ secrets.DBPASSWORD }}
          POSTGRES_DB: ${{ secrets.DBNAME }}
        ports:
          # Map port 5432 of the service to port 5432 on the runner
          - 5432:5432

    steps:
      # 1. Check out your repository code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Set up Go environment (Replaces Node.js)
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'
      
      # 3. Install dependencies and run tests
      - name: Install dependencies
        run: go mod download

      - name: Run tests
        run: go test -v ./...
        # Set environment variables for the test script to connect to the service DB
        env:
          DBUSER: ${{ secrets.DBUSER }}
          DBPASSWORD: ${{ secrets.DBPASSWORD }}
          DBNAME: ${{ secrets.DBNAME }}
          DBHOST: 127.0.0.1 # Service container is mapped to localhost
          DBPORT: ${{ secrets.DBPORT }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Build Application Artifact
        run: |
          sudo apt install zip
          # Zipping Go source files so they can be built on the instance
          # Adjust the folder list based on your actual Go project structure
          sudo zip -r webapp.zip controllers db middleware models routers scripts logs go.mod go.sum main.go

      # Creating .env file which is required by the application
      - name: Creating variable file for packer
        run: |
          cat > packer/config.pkrvars.hcl << EOF
          aws_region   = "${{ vars.AWS_REGION }}"
          aws_dev_id   = "${{ secrets.AWS_DEV_ID }}"
          aws_demo_id  = "${{ secrets.AWS_DEMO_ID }}"
          source_ami   = "${{ vars.SOURCE_AMI }}"
          ubuntu_owner = "${{ vars.UBUNTU_OWNER }}"
          EOF

      - name: Setup Packer
        uses: hashicorp/setup-packer@main
      
      - name: Packer Format Check
        run: packer fmt -check packer/
        
      - name: Init Packer
        run: packer init packer/ 
      - name: Packer Validate
        run: packer validate -var-file="packer/config.pkrvars.hcl" packer/

      - name: Build AMI with Packer
        id: packer_build
        run: |
          packer build -var-file="packer/config.pkrvars.hcl" packer/

      # NEW STEPS 

      - name: Extract AMI ID
        id: extract_ami
        run: |
          AMI_ID=$(jq -r '.builds[-1].artifact_id' manifest.json | cut -d: -f2)
          echo "AMI_ID=$AMI_ID" >> $GITHUB_ENV
          echo " AMI built successfully: $AMI_ID"

      - name: Share AMI with DEMO account
        run: |
          echo "Sharing AMI $AMI_ID with demo account..."
          aws ec2 modify-image-attribute \
            --image-id "$AMI_ID" \
            --launch-permission "Add=[{UserId=${{ secrets.AWS_DEMO_ID }}}]"
          SNAP_IDS=$(aws ec2 describe-images --image-ids "$AMI_ID" \
            --query 'Images[0].BlockDeviceMappings[].Ebs.SnapshotId' --output text)
          for s in $SNAP_IDS; do
            aws ec2 modify-snapshot-attribute --snapshot-id "$s" \
              --attribute createVolumePermission \
              --operation-type add \
              --user-ids "${{ secrets.AWS_DEMO_ID }}"
          done
 
      - name: Configure AWS Credentials (DEMO)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.DEMO_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.DEMO_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
 
      - name: Create new Launch Template version
        id: lt
        run: |
          echo "Creating new Launch Template version with AMI $AMI_ID..."
          NEW_VER=$(aws ec2 create-launch-template-version \
            --launch-template-id "${{ secrets.LAUNCH_TEMPLATE_ID }}" \
            --source-version '$Latest' \
            --launch-template-data "{\"ImageId\":\"$AMI_ID\"}" \
            --query 'LaunchTemplateVersion.VersionNumber' --output text)
          echo "NEW_VER=$NEW_VER" >> $GITHUB_ENV
          aws ec2 modify-launch-template \
            --launch-template-id "${{ secrets.LAUNCH_TEMPLATE_ID }}" \
            --default-version "$NEW_VER"
          echo " Launch Template updated to version $NEW_VER"
 
      - name: Start Auto Scaling Group instance refresh
        id: refresh
        run: |
          echo "Starting instance refresh for ASG..."
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "${{ secrets.ASG_NAME_DEMO }}" \
            --preferences '{"InstanceWarmup":180,"MinHealthyPercentage":90}' \
            --query 'InstanceRefreshId' --output text)
          echo "REFRESH_ID=$REFRESH_ID" >> $GITHUB_ENV
 
      - name: Wait for Instance Refresh to complete
        run: |
          echo "Waiting for instance refresh ($REFRESH_ID) to complete..."
          STATUS="Pending"
          while true; do
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "${{ secrets.ASG_NAME_DEMO }}" \
              --instance-refresh-ids "$REFRESH_ID" \
              --query 'InstanceRefreshes[0].Status' --output text)
            echo "Current status: $STATUS"
            if [ "$STATUS" = "Successful" ]; then
              echo " Instance refresh completed successfully!"
              exit 0
            fi
            if [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
              echo " Instance refresh failed or cancelled."
              exit 1
            fi
            sleep 30
          done